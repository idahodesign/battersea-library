/**
 * Battersea Component Library v1.0.33
 * Lightweight vanilla JavaScript component library
 * No jQuery dependency
 */

(function(window, document) {
  'use strict';

  // Create namespace
  const Battersea = {
    version: '1.0.33',
    components: {},
    initialized: false,
    observer: null
  };

  // Utility functions
  const Utils = {
    // Get data attribute with fallback
    getData(el, key, defaultVal = null) {
      if (!el || !el.dataset) return defaultVal;
      return el.dataset[key] !== undefined ? el.dataset[key] : defaultVal;
    },

    // Check if element is in viewport
    isInViewport(el) {
      if (!el) return false;
      const rect = el.getBoundingClientRect();
      return (
        rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&
        rect.bottom >= 0 &&
        rect.left <= (window.innerWidth || document.documentElement.clientWidth) &&
        rect.right >= 0
      );
    },

    // Debounce function
    debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    },

    // Get transition duration from element
    getTransitionDuration(el) {
      if (!el) return 0;
      const duration = window.getComputedStyle(el).transitionDuration;
      return parseFloat(duration) * 1000;
    },

    // Easing function for animations
    easeOutQuad(t) {
      return t * (2 - t);
    }
  };

  // ========================================
  // TOOLTIP COMPONENT
  // ========================================
  class Tooltip {
    constructor(el) {
      if (!el) return;
      this.el = el;
      this.content = Utils.getData(el, 'tooltip');
      this.position = Utils.getData(el, 'tooltipPosition', 'top');
      this.tooltipEl = null;
      this.init();
    }

    init() {
      this.el.addEventListener('mouseenter', () => this.show());
      this.el.addEventListener('mouseleave', () => this.hide());
      this.el.addEventListener('focus', () => this.show());
      this.el.addEventListener('blur', () => this.hide());
    }

    show() {
      if (this.tooltipEl || !this.content) return;

      this.tooltipEl = document.createElement('div');
      this.tooltipEl.className = `battersea-tooltip battersea-tooltip-${this.position}`;
      this.tooltipEl.textContent = this.content;
      document.body.appendChild(this.tooltipEl);

      this.position === 'top' || this.position === 'bottom' 
        ? this.positionVertical() 
        : this.positionHorizontal();

      setTimeout(() => {
        if (this.tooltipEl) {
          this.tooltipEl.classList.add('battersea-tooltip-show');
        }
      }, 10);
    }

    hide() {
      if (!this.tooltipEl) return;

      this.tooltipEl.classList.remove('battersea-tooltip-show');
      setTimeout(() => {
        if (this.tooltipEl && this.tooltipEl.parentNode) {
          document.body.removeChild(this.tooltipEl);
          this.tooltipEl = null;
        }
      }, 200);
    }

    positionVertical() {
      const rect = this.el.getBoundingClientRect();
      const tooltipRect = this.tooltipEl.getBoundingClientRect();
      
      this.tooltipEl.style.left = `${rect.left + (rect.width / 2) - (tooltipRect.width / 2)}px`;
      
      if (this.position === 'top') {
        this.tooltipEl.style.top = `${rect.top - tooltipRect.height - 8}px`;
      } else {
        this.tooltipEl.style.top = `${rect.bottom + 8}px`;
      }
    }

    positionHorizontal() {
      const rect = this.el.getBoundingClientRect();
      const tooltipRect = this.tooltipEl.getBoundingClientRect();
      
      this.tooltipEl.style.top = `${rect.top + (rect.height / 2) - (tooltipRect.height / 2)}px`;
      
      if (this.position === 'left') {
        this.tooltipEl.style.left = `${rect.left - tooltipRect.width - 8}px`;
      } else {
        this.tooltipEl.style.left = `${rect.right + 8}px`;
      }
    }

    destroy() {
      this.hide();
    }
  }

  // ========================================
  // SLIDER COMPONENT
  // ========================================
  class Slider {
    constructor(el) {
      if (!el) return;
      this.el = el;
      this.track = el.querySelector('[data-slider-track]');
      this.slides = this.track ? Array.from(el.querySelectorAll('[data-slider-item]')) : [];
      this.prevBtn = el.querySelector('[data-slider-prev]');
      this.nextBtn = el.querySelector('[data-slider-next]');
      this.dotsContainer = el.querySelector('[data-slider-dots]');
      this.current = 0;
      this.autoplay = Utils.getData(el, 'sliderAutoplay', 'false') === 'true';
      this.interval = parseInt(Utils.getData(el, 'sliderInterval', '5000'));
      this.transition = Utils.getData(el, 'sliderTransition', 'slide'); // 'slide' or 'fade'
      this.autoplayTimer = null;
      this.touchStartX = 0;
      this.touchEndX = 0;
      this.isTransitioning = false;
      this.init();
    }

    init() {
      if (this.slides.length === 0) return;

      // Set height to smallest slide
      this.setSliderHeight();
      
      // Setup for fade transition
      if (this.transition === 'fade') {
        this.setupFadeTransition();
      }

      this.createDots();
      this.attachEvents();
      this.goToSlide(0, false);

      if (this.autoplay) {
        this.startAutoplay();
      }

      // Recalculate height on window resize
      window.addEventListener('resize', Utils.debounce(() => this.setSliderHeight(), 250));
    }

    setSliderHeight() {
      if (this.slides.length === 0) return;
      
      // Find the smallest height
      let minHeight = Infinity;
      this.slides.forEach(slide => {
        const height = slide.offsetHeight;
        if (height < minHeight && height > 0) {
          minHeight = height;
        }
      });
      
      if (minHeight !== Infinity && minHeight > 0) {
        this.el.style.height = `${minHeight}px`;
      }
    }

    setupFadeTransition() {
      this.slides.forEach((slide, index) => {
        slide.style.position = 'absolute';
        slide.style.top = '0';
        slide.style.left = '0';
        slide.style.width = '100%';
        slide.style.opacity = index === 0 ? '1' : '0';
        slide.style.transition = 'opacity 0.5s ease-in-out';
      });
      
      if (this.track) {
        this.track.style.position = 'relative';
        this.track.style.transform = 'none';
      }
    }

    createDots() {
      if (!this.dotsContainer) return;

      this.slides.forEach((_, index) => {
        const dot = document.createElement('button');
        dot.className = 'battersea-slider-dot';
        dot.setAttribute('aria-label', `Go to slide ${index + 1}`);
        dot.addEventListener('click', () => this.goToSlide(index));
        this.dotsContainer.appendChild(dot);
      });
    }

    attachEvents() {
      if (this.prevBtn) {
        this.prevBtn.addEventListener('click', () => this.prev());
      }
      if (this.nextBtn) {
        this.nextBtn.addEventListener('click', () => this.next());
      }

      // Keyboard navigation
      this.el.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') this.prev();
        if (e.key === 'ArrowRight') this.next();
      });

      // Touch support
      if (this.track) {
        this.track.addEventListener('touchstart', (e) => {
          this.touchStartX = e.changedTouches[0].screenX;
        }, { passive: true });

        this.track.addEventListener('touchend', (e) => {
          this.touchEndX = e.changedTouches[0].screenX;
          this.handleSwipe();
        }, { passive: true });
      }

      // Pause autoplay on hover
      if (this.autoplay) {
        this.el.addEventListener('mouseenter', () => this.stopAutoplay());
        this.el.addEventListener('mouseleave', () => this.startAutoplay());
      }
    }

    handleSwipe() {
      if (this.touchEndX < this.touchStartX - 50) {
        this.next();
      }
      if (this.touchEndX > this.touchStartX + 50) {
        this.prev();
      }
    }

    goToSlide(index, animate = true) {
      if (!this.track || this.isTransitioning) return;
      
      this.current = index;

      if (this.transition === 'fade') {
        this.goToSlideFade(index, animate);
      } else {
        this.goToSlideSlide(index, animate);
      }

      // Update dots
      if (this.dotsContainer) {
        const dots = this.dotsContainer.querySelectorAll('.battersea-slider-dot');
        dots.forEach((dot, i) => {
          dot.classList.toggle('active', i === index);
        });
      }

      // Update ARIA
      this.slides.forEach((slide, i) => {
        slide.setAttribute('aria-hidden', i !== index);
      });
    }

    goToSlideFade(index, animate) {
      this.slides.forEach((slide, i) => {
        if (animate) {
          slide.style.transition = 'opacity 0.5s ease-in-out';
        } else {
          slide.style.transition = 'none';
        }
        slide.style.opacity = i === index ? '1' : '0';
      });
    }

    goToSlideSlide(index, animate) {
      if (!animate) {
        this.track.style.transition = 'none';
      } else {
        this.track.style.transition = 'transform 0.3s ease-in-out';
      }
      
      const offset = -index * 100;
      this.track.style.transform = `translateX(${offset}%)`;
      
      if (!animate) {
        // Force reflow
        this.track.offsetHeight;
        this.track.style.transition = 'transform 0.3s ease-in-out';
      }
    }

    next() {
      if (this.isTransitioning) return;
      
      const nextIndex = (this.current + 1) % this.slides.length;
      this.goToSlide(nextIndex);
    }

    prev() {
      if (this.isTransitioning) return;
      
      const prevIndex = (this.current - 1 + this.slides.length) % this.slides.length;
      this.goToSlide(prevIndex);
    }

    startAutoplay() {
      this.stopAutoplay();
      this.autoplayTimer = setInterval(() => this.next(), this.interval);
    }

    stopAutoplay() {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
        this.autoplayTimer = null;
      }
    }

    destroy() {
      this.stopAutoplay();
    }
  }

  // ========================================
  // TABS COMPONENT
  // ========================================
  class Tabs {
    constructor(el) {
      if (!el) return;
      this.el = el;
      this.tabList = el.querySelector('[data-tabs-list]');
      this.tabs = Array.from(el.querySelectorAll('[data-tab]'));
      this.panels = Array.from(el.querySelectorAll('[data-tab-panel]'));
      this.init();
    }

    init() {
      if (this.tabs.length === 0) return;

      this.attachEvents();
      this.setupAccessibility();
      
      // Activate first tab
      const activeTab = this.tabs.find(tab => tab.classList.contains('active'));
      if (activeTab) {
        this.activateTab(activeTab);
      } else {
        this.activateTab(this.tabs[0]);
      }
    }

    setupAccessibility() {
      if (this.tabList) {
        this.tabList.setAttribute('role', 'tablist');
      }
      
      this.tabs.forEach((tab, index) => {
        tab.setAttribute('role', 'tab');
        tab.setAttribute('id', `tab-${this.el.id || 'default'}-${index}`);
        tab.setAttribute('aria-controls', `panel-${this.el.id || 'default'}-${index}`);
        tab.setAttribute('tabindex', '-1');
      });

      this.panels.forEach((panel, index) => {
        panel.setAttribute('role', 'tabpanel');
        panel.setAttribute('id', `panel-${this.el.id || 'default'}-${index}`);
        panel.setAttribute('aria-labelledby', `tab-${this.el.id || 'default'}-${index}`);
        panel.setAttribute('tabindex', '0');
      });
    }

    attachEvents() {
      this.tabs.forEach(tab => {
        tab.addEventListener('click', (e) => {
          e.preventDefault();
          this.activateTab(tab);
        });

        tab.addEventListener('keydown', (e) => this.handleKeydown(e));
      });
    }

    handleKeydown(e) {
      const index = this.tabs.indexOf(e.target);
      let newIndex = index;

      if (e.key === 'ArrowLeft') {
        newIndex = index - 1 < 0 ? this.tabs.length - 1 : index - 1;
      } else if (e.key === 'ArrowRight') {
        newIndex = (index + 1) % this.tabs.length;
      } else if (e.key === 'Home') {
        newIndex = 0;
      } else if (e.key === 'End') {
        newIndex = this.tabs.length - 1;
      } else {
        return;
      }

      e.preventDefault();
      this.activateTab(this.tabs[newIndex]);
      this.tabs[newIndex].focus();
    }

    activateTab(activeTab) {
      const index = this.tabs.indexOf(activeTab);

      this.tabs.forEach((tab, i) => {
        const isActive = i === index;
        tab.classList.toggle('active', isActive);
        tab.setAttribute('aria-selected', isActive);
        tab.setAttribute('tabindex', isActive ? '0' : '-1');
      });

      this.panels.forEach((panel, i) => {
        panel.classList.toggle('active', i === index);
        panel.hidden = i !== index;
      });
    }

    destroy() {
      // Cleanup if needed
    }
  }

  // ========================================
  // POPUP/MODAL COMPONENT
  // ========================================
  class Popup {
    constructor(trigger) {
      if (!trigger) return;
      this.trigger = trigger;
      this.targetId = Utils.getData(trigger, 'popup');
      this.popup = this.targetId ? document.getElementById(this.targetId) : null;
      this.closeBtn = this.popup ? this.popup.querySelector('[data-popup-close]') : null;
      this.init();
    }

    init() {
      if (!this.popup) return;

      this.trigger.addEventListener('click', (e) => {
        e.preventDefault();
        this.open();
      });

      if (this.closeBtn) {
        this.closeBtn.addEventListener('click', () => this.close());
      }

      this.popup.addEventListener('click', (e) => {
        if (e.target === this.popup) this.close();
      });

      const escapeHandler = (e) => {
        if (e.key === 'Escape' && this.popup.classList.contains('active')) {
          this.close();
        }
      };
      
      document.addEventListener('keydown', escapeHandler);
      this.escapeHandler = escapeHandler;
    }

    open() {
      this.popup.classList.add('active');
      this.popup.setAttribute('aria-hidden', 'false');
      document.body.style.overflow = 'hidden';
      
      // Focus management
      const focusable = this.popup.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
      if (focusable) focusable.focus();
    }

    close() {
      this.popup.classList.remove('active');
      this.popup.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';
      this.trigger.focus();
    }

    destroy() {
      if (this.escapeHandler) {
        document.removeEventListener('keydown', this.escapeHandler);
      }
    }
  }

  // ========================================
  // ACCORDION COMPONENT
  // ========================================
  class Accordion {
    constructor(el) {
      if (!el) return;
      this.el = el;
      this.items = Array.from(el.querySelectorAll('[data-accordion-item]'));
      this.allowMultiple = Utils.getData(el, 'accordionMultiple', 'false') === 'true';
      this.init();
    }

    init() {
      if (this.items.length === 0) return;

      this.items.forEach((item, index) => {
        const trigger = item.querySelector('[data-accordion-trigger]');
        const content = item.querySelector('[data-accordion-content]');

        if (!trigger || !content) return;

        // Setup accessibility
        trigger.setAttribute('id', `accordion-trigger-${this.el.id || 'default'}-${index}`);
        trigger.setAttribute('aria-controls', `accordion-content-${this.el.id || 'default'}-${index}`);
        trigger.setAttribute('aria-expanded', 'false');
        
        content.setAttribute('id', `accordion-content-${this.el.id || 'default'}-${index}`);
        content.setAttribute('role', 'region');
        content.setAttribute('aria-labelledby', `accordion-trigger-${this.el.id || 'default'}-${index}`);

        trigger.addEventListener('click', () => this.toggle(item));
        
        // Keyboard support
        trigger.addEventListener('keydown', (e) => this.handleKeydown(e, index));
      });
    }

    handleKeydown(e, index) {
      let newIndex = index;

      if (e.key === 'ArrowDown') {
        newIndex = (index + 1) % this.items.length;
      } else if (e.key === 'ArrowUp') {
        newIndex = index - 1 < 0 ? this.items.length - 1 : index - 1;
      } else if (e.key === 'Home') {
        newIndex = 0;
      } else if (e.key === 'End') {
        newIndex = this.items.length - 1;
      } else {
        return;
      }

      e.preventDefault();
      const newTrigger = this.items[newIndex].querySelector('[data-accordion-trigger]');
      if (newTrigger) newTrigger.focus();
    }

    toggle(item) {
      const trigger = item.querySelector('[data-accordion-trigger]');
      const content = item.querySelector('[data-accordion-content]');
      const isOpen = item.classList.contains('active');

      if (!this.allowMultiple) {
        this.items.forEach(otherItem => {
          if (otherItem !== item) {
            this.close(otherItem);
          }
        });
      }

      if (isOpen) {
        this.close(item);
      } else {
        this.open(item);
      }
    }

    open(item) {
      const trigger = item.querySelector('[data-accordion-trigger]');
      const content = item.querySelector('[data-accordion-content]');
      
      if (!trigger || !content) return;
      
      item.classList.add('active');
      trigger.setAttribute('aria-expanded', 'true');
      content.style.maxHeight = content.scrollHeight + 'px';
    }

    close(item) {
      const trigger = item.querySelector('[data-accordion-trigger]');
      const content = item.querySelector('[data-accordion-content]');
      
      if (!trigger || !content) return;
      
      item.classList.remove('active');
      trigger.setAttribute('aria-expanded', 'false');
      content.style.maxHeight = '0';
    }

    destroy() {
      // Cleanup if needed
    }
  }

  // ========================================
  // COUNTER COMPONENT
  // ========================================
  class Counter {
    constructor(el) {
      if (!el) return;
      this.el = el;
      this.target = parseFloat(Utils.getData(el, 'counterTarget', '100'));
      this.duration = parseInt(Utils.getData(el, 'counterDuration', '2000'));
      this.prefix = Utils.getData(el, 'counterPrefix', '');
      this.suffix = Utils.getData(el, 'counterSuffix', '');
      this.pretext = Utils.getData(el, 'counterPretext', '');
      this.posttext = Utils.getData(el, 'counterPosttext', '');
      this.decimals = parseInt(Utils.getData(el, 'counterDecimals', '0'));
      this.separator = Utils.getData(el, 'counterSeparator', 'true') === 'true';
      this.hasAnimated = false;
      this.init();
    }

    init() {
      this.setupObserver();
    }

    setupObserver() {
      if ('IntersectionObserver' in window) {
        this.observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting && !this.hasAnimated) {
              this.animate();
              this.observer.unobserve(this.el);
            }
          });
        }, { threshold: 0.5 });

        this.observer.observe(this.el);
      } else {
        this.animate();
      }
    }

    formatNumber(num) {
      let formattedValue;
      
      if (this.decimals > 0) {
        formattedValue = num.toFixed(this.decimals);
      } else {
        formattedValue = Math.floor(num).toString();
      }

      // Add thousand separators if enabled
      if (this.separator) {
        const parts = formattedValue.split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        formattedValue = parts.join('.');
      }

      return formattedValue;
    }

    animate() {
      this.hasAnimated = true;
      const startTime = performance.now();
      const startValue = 0;

      const update = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / this.duration, 1);
        const easedProgress = Utils.easeOutQuad(progress);
        const currentValue = startValue + (this.target - startValue) * easedProgress;

        const formattedValue = this.formatNumber(currentValue);

        // Build HTML with styled spans
        let displayHTML = '';
        if (this.pretext) displayHTML += `<span class="battersea-counter-pretext">${this.pretext}</span> `;
        if (this.prefix) displayHTML += `<span class="battersea-counter-prefix">${this.prefix}</span>`;
        displayHTML += `<span class="battersea-counter-number">${formattedValue}</span>`;
        if (this.suffix) displayHTML += `<span class="battersea-counter-suffix">${this.suffix}</span>`;
        if (this.posttext) displayHTML += ` <span class="battersea-counter-posttext">${this.posttext}</span>`;

        this.el.innerHTML = displayHTML;

        if (progress < 1) {
          requestAnimationFrame(update);
        }
      };

      requestAnimationFrame(update);
    }

    destroy() {
      if (this.observer) {
        this.observer.disconnect();
      }
    }
  }

  // ========================================
  // NESTED CIRCULAR PROGRESS COMPONENT
  // ========================================
  class NestedProgress {
    constructor(el) {
      if (!el) return;
      this.el = el;
      this.circles = this.parseCircles();
      this.duration = parseInt(Utils.getData(el, 'progressDuration', '1500'));
      this.hasAnimated = false;
      this.init();
    }

    parseCircles() {
      const circlesData = Utils.getData(this.el, 'progressCircles', '');
      if (!circlesData) return [];
      
      try {
        return JSON.parse(circlesData);
      } catch (e) {
        console.error('Invalid progress circles data:', e);
        return [];
      }
    }

    init() {
      if (this.circles.length === 0) return;
      this.createSVG();
      this.setupObserver();
    }

    createSVG() {
      // Get container size for responsive sizing
      const containerWidth = this.el.offsetWidth || 200;
      const size = Math.min(containerWidth, 300); // Max 300px
      const maxStrokeWidth = Math.max(10, size / 20);
      const spacing = Math.max(3, size / 50);
      
      let svgContent = '';
      let currentRadius = (size - maxStrokeWidth) / 2;

      this.circles.forEach((circle, index) => {
        const strokeWidth = circle.strokeWidth || maxStrokeWidth;
        const circumference = 2 * Math.PI * currentRadius;
        
        svgContent += `
          <circle class="battersea-nested-progress-track" 
            cx="${size/2}" cy="${size/2}" r="${currentRadius}" 
            stroke-width="${strokeWidth}" 
            stroke="${circle.trackColor || '#e0e0e0'}"
            fill="none"/>
          <circle class="battersea-nested-progress-fill battersea-nested-${index}" 
            cx="${size/2}" cy="${size/2}" r="${currentRadius}" 
            stroke-width="${strokeWidth}" 
            stroke="${circle.fillColor || '#007bff'}"
            fill="none"
            stroke-dasharray="${circumference}"
            stroke-dashoffset="${circumference}"
            data-value="${circle.value}"
            data-circumference="${circumference}"/>
        `;
        
        currentRadius -= (strokeWidth + spacing);
      });

      // Add center label if provided
      const label = Utils.getData(this.el, 'progressLabel', '');
      if (label) {
        svgContent += `<text class="battersea-nested-progress-text" x="50%" y="50%" text-anchor="middle" dy=".3em" font-size="${size/10}">${label}</text>`;
      }

      this.el.innerHTML = `
        <svg class="battersea-progress-nested" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
          ${svgContent}
        </svg>
      `;
      
      this.fillElements = this.el.querySelectorAll('.battersea-nested-progress-fill');
      
      // Update on resize
      window.addEventListener('resize', Utils.debounce(() => {
        if (!this.hasAnimated) return;
        const newSize = Math.min(this.el.offsetWidth || 200, 300);
        if (Math.abs(newSize - size) > 10) {
          this.createSVG();
          this.hasAnimated = false;
          this.setupObserver();
        }
      }, 250));
    }

    setupObserver() {
      if ('IntersectionObserver' in window) {
        this.observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting && !this.hasAnimated) {
              this.animate();
              this.observer.unobserve(this.el);
            }
          });
        }, { threshold: 0.5 });

        this.observer.observe(this.el);
      } else {
        this.animate();
      }
    }

    animate() {
      this.hasAnimated = true;
      const startTime = performance.now();

      const update = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / this.duration, 1);
        const easedProgress = Utils.easeOutQuad(progress);

        this.fillElements.forEach(fillEl => {
          const targetValue = parseFloat(fillEl.dataset.value);
          const circumference = parseFloat(fillEl.dataset.circumference);
          const currentValue = targetValue * easedProgress;
          const offset = circumference - (currentValue / 100) * circumference;
          fillEl.style.strokeDashoffset = offset;
        });

        if (progress < 1) {
          requestAnimationFrame(update);
        }
      };

      requestAnimationFrame(update);
    }

    destroy() {
      if (this.observer) {
        this.observer.disconnect();
      }
    }
  }

  // ========================================
  // MULTI-ITEM SLIDER COMPONENT
  // ========================================
  class MultiSlider {
    constructor(el) {
      if (!el) return;
      this.el = el;
      this.track = el.querySelector('[data-multislider-track]');
      this.items = this.track ? Array.from(el.querySelectorAll('[data-multislider-item]')) : [];
      this.prevBtn = el.querySelector('[data-multislider-prev]');
      this.nextBtn = el.querySelector('[data-multislider-next]');
      this.itemsPerView = parseInt(Utils.getData(el, 'multisliderItems', '3'));
      this.itemsPerViewMd = parseInt(Utils.getData(el, 'multisliderItemsMd', '2'));
      this.itemsPerViewSm = parseInt(Utils.getData(el, 'multisliderItemsSm', '1'));
      this.gap = parseInt(Utils.getData(el, 'multisliderGap', '20'));
      this.autoplay = Utils.getData(el, 'multisliderAutoplay', 'false') === 'true';
      this.interval = parseInt(Utils.getData(el, 'multisliderInterval', '5000'));
      this.current = 0;
      this.autoplayTimer = null;
      this.currentItemsPerView = this.itemsPerView;
      this.init();
    }

    init() {
      if (this.items.length === 0) return;

      this.setupItems();
      this.attachEvents();
      this.goToSlide(0);

      if (this.autoplay) {
        this.startAutoplay();
      }

      window.addEventListener('resize', Utils.debounce(() => {
        this.updateResponsive();
        this.updateItemWidth();
        this.goToSlide(this.current);
      }, 250));
    }

    updateResponsive() {
      const width = window.innerWidth;
      
      if (width < 768) {
        this.currentItemsPerView = this.itemsPerViewSm;
      } else if (width < 1024) {
        this.currentItemsPerView = this.itemsPerViewMd;
      } else {
        this.currentItemsPerView = this.itemsPerView;
      }
    }

    setupItems() {
      this.updateResponsive();
      this.updateItemWidth();
    }

    updateItemWidth() {
      const containerWidth = this.el.offsetWidth;
      const totalGap = this.gap * (this.currentItemsPerView - 1);
      const itemWidth = (containerWidth - totalGap) / this.currentItemsPerView;
      
      this.items.forEach((item, index) => {
        item.style.width = `${itemWidth}px`;
        item.style.minWidth = `${itemWidth}px`;
        item.style.maxWidth = `${itemWidth}px`;
        item.style.flex = '0 0 auto';
        item.style.marginRight = `${this.gap}px`;
      });
      
      // Remove margin from last item
      if (this.items.length > 0) {
        this.items[this.items.length - 1].style.marginRight = '0';
      }
    }

    attachEvents() {
      if (this.prevBtn) {
        this.prevBtn.addEventListener('click', () => this.prev());
      }
      if (this.nextBtn) {
        this.nextBtn.addEventListener('click', () => this.next());
      }

      // Keyboard navigation
      this.el.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') this.prev();
        if (e.key === 'ArrowRight') this.next();
      });

      // Pause autoplay on hover
      if (this.autoplay) {
        this.el.addEventListener('mouseenter', () => this.stopAutoplay());
        this.el.addEventListener('mouseleave', () => this.startAutoplay());
      }
    }

    goToSlide(index) {
      const maxScroll = Math.max(0, this.items.length - this.currentItemsPerView);
      this.current = Math.min(Math.max(0, index), maxScroll);
      
      const containerWidth = this.el.offsetWidth;
      const itemWidth = (containerWidth - (this.gap * (this.currentItemsPerView - 1))) / this.currentItemsPerView;
      const offset = -(this.current * (itemWidth + this.gap));
      
      this.track.style.transform = `translateX(${offset}px)`;
    }

    next() {
      const maxScroll = Math.max(0, this.items.length - this.currentItemsPerView);
      if (this.current < maxScroll) {
        this.goToSlide(this.current + 1);
      } else {
        this.goToSlide(0); // Loop back
      }
    }

    prev() {
      const maxScroll = Math.max(0, this.items.length - this.currentItemsPerView);
      if (this.current > 0) {
        this.goToSlide(this.current - 1);
      } else {
        this.goToSlide(maxScroll); // Loop to end
      }
    }

    startAutoplay() {
      this.stopAutoplay();
      this.autoplayTimer = setInterval(() => this.next(), this.interval);
    }

    stopAutoplay() {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
        this.autoplayTimer = null;
      }
    }

    destroy() {
      this.stopAutoplay();
    }
  }

  // ========================================
  // PARALLAX COMPONENT
  // ========================================
  class Parallax {
    constructor(el) {
      if (!el) return;
      this.el = el;
      this.speed = parseFloat(Utils.getData(el, 'parallaxSpeed', '0.5'));
      this.init();
    }

    init() {
      // Ensure background covers the container
      this.el.style.backgroundSize = 'cover';
      this.el.style.backgroundPosition = 'center center';
      
      this.update = this.update.bind(this);
      window.addEventListener('scroll', Utils.debounce(this.update, 10));
      window.addEventListener('resize', () => this.update());
      this.update();
    }

    update() {
      const rect = this.el.getBoundingClientRect();
      const scrolled = window.pageYOffset;
      const elementTop = rect.top + scrolled;
      const windowHeight = window.innerHeight;
      const elementHeight = this.el.offsetHeight;
      
      // Calculate if element is in viewport
      if (rect.top < windowHeight && rect.bottom > 0) {
        // Calculate parallax offset
        const viewportCenter = scrolled + windowHeight / 2;
        const elementCenter = elementTop + elementHeight / 2;
        const distance = viewportCenter - elementCenter;
        const yPos = distance * this.speed;
        
        this.el.style.backgroundPosition = `center calc(50% + ${yPos}px)`;
      }
    }

    destroy() {
      window.removeEventListener('scroll', this.update);
      window.removeEventListener('resize', this.update);
    }
  }

  // ========================================
  // FLIPBOX COMPONENT
  // ========================================
  class Flipbox {
    constructor(el) {
      if (!el) return;
      this.el = el;
      this.direction = Utils.getData(el, 'flipboxDirection', 'horizontal'); // horizontal or vertical
      this.trigger = Utils.getData(el, 'flipboxTrigger', 'hover'); // hover or click
      this.isFlipped = false;
      this.init();
    }

    init() {
      this.el.classList.add(`battersea-flipbox-${this.direction}`);
      
      if (this.trigger === 'hover') {
        this.el.addEventListener('mouseenter', () => this.flip());
        this.el.addEventListener('mouseleave', () => this.unflip());
      } else {
        this.el.addEventListener('click', () => this.toggle());
      }
    }

    flip() {
      this.isFlipped = true;
      this.el.classList.add('battersea-flipbox-flipped');
    }

    unflip() {
      this.isFlipped = false;
      this.el.classList.remove('battersea-flipbox-flipped');
    }

    toggle() {
      if (this.isFlipped) {
        this.unflip();
      } else {
        this.flip();
      }
    }

    destroy() {
      // Cleanup if needed
    }
  }

  // ========================================
  // PROGRESS BAR COMPONENT
  // ========================================
  class ProgressBar {
    constructor(el) {
      if (!el) return;
      this.el = el;
      this.type = Utils.getData(el, 'progressType', 'horizontal'); // 'horizontal' or 'circular'
      this.value = parseInt(Utils.getData(el, 'progressValue', '75'));
      this.duration = parseInt(Utils.getData(el, 'progressDuration', '1500'));
      this.label = Utils.getData(el, 'progressLabel', '');
      this.showValue = Utils.getData(el, 'progressShowValue', 'true') === 'true';
      this.hasAnimated = false;
      this.init();
    }

    init() {
      if (this.type === 'circular') {
        this.initCircular();
      } else {
        this.initHorizontal();
      }
      this.setupObserver();
    }

    initHorizontal() {
      this.el.innerHTML = `
        ${this.label ? `<div class="battersea-progress-label">${this.label}</div>` : ''}
        <div class="battersea-progress-track">
          <div class="battersea-progress-fill" style="width: 0%"></div>
        </div>
        ${this.showValue ? `<div class="battersea-progress-value">0%</div>` : ''}
      `;
      this.fillEl = this.el.querySelector('.battersea-progress-fill');
      this.valueEl = this.el.querySelector('.battersea-progress-value');
    }

    initCircular() {
      // Get container size for responsive sizing
      const containerWidth = this.el.offsetWidth || 120;
      const size = Math.min(containerWidth, 200); // Max 200px
      const strokeWidth = Math.max(8, size / 15); // Scale stroke width
      const radius = (size - strokeWidth) / 2;
      const circumference = 2 * Math.PI * radius;

      this.el.innerHTML = `
        <svg class="battersea-progress-circular" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
          <circle class="battersea-progress-circular-track" 
            cx="${size/2}" cy="${size/2}" r="${radius}" 
            stroke-width="${strokeWidth}" fill="none"/>
          <circle class="battersea-progress-circular-fill" 
            cx="${size/2}" cy="${size/2}" r="${radius}" 
            stroke-width="${strokeWidth}" fill="none"
            stroke-dasharray="${circumference}"
            stroke-dashoffset="${circumference}"/>
          ${this.showValue ? `<text class="battersea-progress-circular-text" x="50%" y="50%" text-anchor="middle" dy=".3em" font-size="${size/6}">0%</text>` : ''}
        </svg>
        ${this.label ? `<div class="battersea-progress-label">${this.label}</div>` : ''}
      `;
      this.fillEl = this.el.querySelector('.battersea-progress-circular-fill');
      this.valueEl = this.el.querySelector('.battersea-progress-circular-text');
      this.circumference = circumference;
      
      // Update on resize
      window.addEventListener('resize', Utils.debounce(() => {
        if (!this.hasAnimated) return;
        const newSize = Math.min(this.el.offsetWidth || 120, 200);
        if (Math.abs(newSize - size) > 10) {
          this.initCircular();
          this.hasAnimated = false;
          this.setupObserver();
        }
      }, 250));
    }

    setupObserver() {
      if ('IntersectionObserver' in window) {
        this.observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting && !this.hasAnimated) {
              this.animate();
              this.observer.unobserve(this.el);
            }
          });
        }, { threshold: 0.5 });

        this.observer.observe(this.el);
      } else {
        this.animate();
      }
    }

    animate() {
      this.hasAnimated = true;
      const startTime = performance.now();

      const update = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / this.duration, 1);
        const easedProgress = Utils.easeOutQuad(progress);
        const currentValue = this.value * easedProgress;

        if (this.type === 'circular') {
          const offset = this.circumference - (currentValue / 100) * this.circumference;
          this.fillEl.style.strokeDashoffset = offset;
        } else {
          this.fillEl.style.width = currentValue + '%';
        }

        if (this.valueEl) {
          this.valueEl.textContent = Math.floor(currentValue) + '%';
        }

        if (progress < 1) {
          requestAnimationFrame(update);
        }
      };

      requestAnimationFrame(update);
    }

    destroy() {
      if (this.observer) {
        this.observer.disconnect();
      }
    }
  }

  // ========================================
  // ANIMATION COMPONENT
  // ========================================
  class Animation {
    constructor() {
      this.elements = [];
      this.observer = null;
      this.init();
    }

    init() {
      this.elements = Array.from(document.querySelectorAll('[data-animate]'));
      
      if (this.elements.length === 0) return;

      // Immediately hide all elements that should animate
      this.hideAllAnimatableElements();

      if ('IntersectionObserver' in window) {
        this.observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting && !entry.target.classList.contains('battersea-animated')) {
              this.animateElement(entry.target);
            }
          });
        }, { threshold: 0.1 });

        this.elements.forEach(el => {
          this.observer.observe(el);
        });
      } else {
        // Fallback for browsers without IntersectionObserver
        this.elements.forEach(el => this.animateElement(el));
      }
    }

    hideAllAnimatableElements() {
      // Hide all parent elements
      this.elements.forEach(el => {
        el.style.opacity = '0';
        el.style.visibility = 'hidden';
      });

      // Hide all children and grandchildren of animatable parents
      this.elements.forEach(parent => {
        const children = Array.from(parent.children);
        children.forEach(child => {
          if (!Utils.getData(child, 'animate')) {
            child.style.opacity = '0';
            child.style.visibility = 'hidden';
            
            // Hide grandchildren too
            const grandchildren = Array.from(child.children);
            grandchildren.forEach(grandchild => {
              if (!Utils.getData(grandchild, 'animate')) {
                grandchild.style.opacity = '0';
                grandchild.style.visibility = 'hidden';
              }
            });
          }
        });
      });
    }

    animateElement(el) {
      const animation = Utils.getData(el, 'animate');
      const delay = this.getDelay(el) + 500; // Add 500ms base delay

      setTimeout(() => {
        // Make element visible and start animation
        el.style.visibility = 'visible';
        el.classList.add('battersea-animated', `battersea-${animation}`);
        
        // Wait for parent animation to complete before showing children
        const animationDuration = parseFloat(getComputedStyle(el).animationDuration) * 1000 || 600;
        
        setTimeout(() => {
          this.animateChildren(el, animation);
        }, animationDuration);
      }, delay);

      if (this.observer) {
        this.observer.unobserve(el);
      }
    }

    animateChildren(parent, parentAnimation) {
      const children = Array.from(parent.children);
      
      children.forEach((child, index) => {
        const childAnimation = Utils.getData(child, 'animate');
        
        // Only animate children without their own animation attribute
        if (!childAnimation && !child.classList.contains('battersea-animated')) {
          const delay = this.getDelay(child) || (index + 1) * 100;
          
          setTimeout(() => {
            // Make child visible and start animation
            child.style.visibility = 'visible';
            child.classList.add('battersea-animated', `battersea-${parentAnimation}`);
            
            // Wait for child animation to complete before showing grandchildren
            const animationDuration = parseFloat(getComputedStyle(child).animationDuration) * 1000 || 600;
            
            setTimeout(() => {
              this.animateGrandchildren(child, parentAnimation);
            }, animationDuration);
          }, delay);
        }
      });
    }

    animateGrandchildren(child, animation) {
      const grandchildren = Array.from(child.children);
      
      if (grandchildren.length > 0) {
        grandchildren.forEach((grandchild, gIndex) => {
          const grandchildAnimation = Utils.getData(grandchild, 'animate');
          
          // Only animate grandchildren without their own animation attribute
          if (!grandchildAnimation && !grandchild.classList.contains('battersea-animated')) {
            const grandchildDelay = this.getDelay(grandchild) || (gIndex + 1) * 100;
            
            setTimeout(() => {
              // Make grandchild visible and start animation
              grandchild.style.visibility = 'visible';
              grandchild.classList.add('battersea-animated', `battersea-${animation}`);
            }, grandchildDelay);
          }
        });
      }
    }

    getDelay(el) {
      const classes = el.className.split(' ');
      const delayClass = classes.find(cls => cls.startsWith('delay-'));
      
      if (delayClass) {
        const delayValue = parseInt(delayClass.replace('delay-', ''));
        return delayValue * 100; // delay-5 = 500ms
      }
      
      return 0;
    }

    refresh() {
      if (this.observer) {
        this.elements.forEach(el => {
          if (!el.classList.contains('battersea-animated')) {
            this.observer.observe(el);
          }
        });
      }
    }

    destroy() {
      if (this.observer) {
        this.observer.disconnect();
      }
    }
  }

  // ========================================
  // INITIALIZATION
  // ========================================
  Battersea.init = function() {
    try {
      console.log('Battersea.init() called');
      
      // Initialize all components
      const tooltips = document.querySelectorAll('[data-tooltip]');
      console.log('Found', tooltips.length, 'tooltips');
      tooltips.forEach(el => {
        if (!el.batterseaTooltip) {
          el.batterseaTooltip = new Tooltip(el);
        }
      });

      const sliders = document.querySelectorAll('[data-slider]');
      console.log('Found', sliders.length, 'sliders');
      sliders.forEach(el => {
        if (!el.batterseaSlider) {
          el.batterseaSlider = new Slider(el);
        }
      });

      const tabs = document.querySelectorAll('[data-tabs]');
      console.log('Found', tabs.length, 'tabs');
      tabs.forEach(el => {
        if (!el.batterseaTabs) {
          el.batterseaTabs = new Tabs(el);
        }
      });

      const popups = document.querySelectorAll('[data-popup]');
      console.log('Found', popups.length, 'popups');
      popups.forEach(el => {
        if (!el.batterseaPopup) {
          el.batterseaPopup = new Popup(el);
        }
      });

      const accordions = document.querySelectorAll('[data-accordion]');
      console.log('Found', accordions.length, 'accordions');
      accordions.forEach(el => {
        if (!el.batterseaAccordion) {
          el.batterseaAccordion = new Accordion(el);
        }
      });

      const counters = document.querySelectorAll('[data-counter]');
      console.log('Found', counters.length, 'counters');
      counters.forEach(el => {
        if (!el.batterseaCounter) {
          el.batterseaCounter = new Counter(el);
        }
      });

      const progressBars = document.querySelectorAll('[data-progress]');
      console.log('Found', progressBars.length, 'progress bars');
      progressBars.forEach(el => {
        if (!el.batterseaProgress) {
          el.batterseaProgress = new ProgressBar(el);
        }
      });

      const nestedProgress = document.querySelectorAll('[data-progress-nested]');
      console.log('Found', nestedProgress.length, 'nested progress');
      nestedProgress.forEach(el => {
        if (!el.batterseaNestedProgress) {
          el.batterseaNestedProgress = new NestedProgress(el);
        }
      });

      const multiSliders = document.querySelectorAll('[data-multislider]');
      console.log('Found', multiSliders.length, 'multi-sliders');
      console.log('MultiSlider class exists?', typeof MultiSlider);
      console.log('MultiSlider:', MultiSlider);
      
      multiSliders.forEach(el => {
        console.log('Initializing multi-slider:', el);
        if (!el.batterseaMultiSlider) {
          try {
            console.log('About to create new MultiSlider...');
            console.log('Creating with element:', el);
            const instance = new MultiSlider(el);
            console.log('Instance created:', instance);
            el.batterseaMultiSlider = instance;
            console.log('MultiSlider created successfully');
          } catch (error) {
            console.error('Error creating MultiSlider:', error);
            console.error('Error stack:', error.stack);
          }
        }
      });

      const parallaxElements = document.querySelectorAll('[data-parallax]');
      console.log('Found', parallaxElements.length, 'parallax elements');
      parallaxElements.forEach(el => {
        if (!el.batterseaParallax) {
          el.batterseaParallax = new Parallax(el);
        }
      });

      const flipboxes = document.querySelectorAll('[data-flipbox]');
      console.log('Found', flipboxes.length, 'flipboxes');
      flipboxes.forEach(el => {
        if (!el.batterseaFlipbox) {
          el.batterseaFlipbox = new Flipbox(el);
        }
      });

      // Initialize animations
      if (!Battersea.animation) {
        Battersea.animation = new Animation();
      } else {
        Battersea.animation.refresh();
      }
      
      Battersea.initialized = true;
      console.log('Battersea initialization complete');
    } catch (error) {
      console.error('Battersea initialization error:', error);
    }
  };

  // Setup MutationObserver for dynamic content
  Battersea.setupObserver = function() {
    if (!('MutationObserver' in window)) {
      console.warn('MutationObserver not supported, dynamic content detection disabled');
      return;
    }

    try {
      const observer = new MutationObserver(Utils.debounce(() => {
        Battersea.init();
      }, 100));

      observer.observe(document.body, {
        childList: true,
        subtree: true
      });

      Battersea.observer = observer;
    } catch (error) {
      console.error('Battersea observer setup error:', error);
    }
  };

  // Expose classes for manual instantiation
  Battersea.Tooltip = Tooltip;
  Battersea.Slider = Slider;
  Battersea.Tabs = Tabs;
  Battersea.Popup = Popup;
  Battersea.Accordion = Accordion;
  Battersea.Counter = Counter;
  Battersea.ProgressBar = ProgressBar;
  Battersea.NestedProgress = NestedProgress;
  Battersea.MultiSlider = MultiSlider;
  Battersea.Parallax = Parallax;
  Battersea.Flipbox = Flipbox;
  Battersea.Animation = Animation;

  // Initialize on DOM ready
  function initializeBattersea() {
    try {
      Battersea.init();
      Battersea.setupObserver();
    } catch (error) {
      console.error('Battersea startup error:', error);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeBattersea);
  } else {
    // DOM already loaded, initialize immediately
    initializeBattersea();
  }

  // Expose to window
  window.Battersea = Battersea;

})(window, document)